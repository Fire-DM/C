#define _CRT_SECURE_NO_WARNINGS

#include "function.h"

//整型提升

//int main()
//{
//	/*int a = 2 + 6 / 3;
//	int b = 2 + 6 + 3;*/
//
//
//	//C的整型算术运算总是至少以缺省整型类型的精度来进行的
//	//表达式中的字符和短整型操作数在使用之前被转换为普通整数，这种转换就是整型提升	
//
//	//长度小于int的整数值，都必须先转化为int或unsigned int，然后送入CPU去运算
//	char a = 5;
//	//0000 0000 0000 0000 0000 0000 0000 0101 
//	//0000 0101 - a（截断，存储在a中）
//
//	char b = 126;
//	//0000 0000 0000 0000 0000 0000 0111 1110
//	//0111 1110 - b
//
//	char c = a + b;
//	//整型提升
//	//0000 0000 0000 0000 0000 0000 0000 0101 - a
//	//0000 0000 0000 0000 0000 0000 0111 1110 - b
//	// 相加
//	//0000 0000 0000 0000 0000 0000 1000 0011
//	// 截断成1个字节（char类型）
//	//1000 0011 - c
//	//打印时进行整型提升
//	// char有符号，最高位看做符号位，是1就补1
//	//1111 1111 1111 1111 1111 1111 1000 0011 - 补码
//	//1111 1111 1111 1111 1111 1111 1000 0010 - 反码
//	//1000 0000 0000 0000 0000 0000 0111 1101 - 原码（-125）
//
//
//	printf("%d\n", c);//-125
//
//	return 0;
//
//}

//int main()
//{
//	char a1 = 0xb6;//1011 0110 - 补码
//	unsigned char a2 = 0xb6;//1011 0110 - 补码
//	//使用时会整型提升，char的高位补位数根据首位决定，但unsigned类型只用0补位
//	
//	short b = 0xb600;
//	int c = 0xb6000000;
//
//	if (a1 == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	//a,b发生整型提升
//
//	return 0;
//}


//算数转换

//操作符的优先级
//int main()
//{
//	//问题代码
//	//a*b+c*d+e*f
//	//先算a*b和c*d，再算它们相加得A，然后算e*f，最后与A相加
//	//先算a*b、c*d和e*f，再算它们相加
//	//在这个式子中结果不变，但若他们之间存在关联，就会出现问题
//	//因此，表达式一定要简单，不然会出现问题
//
//	return 0;
//}

//int main()
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	//先算三个括号，得出a=4，然后依次相加
//	printf("%d\n", b);//12
//
//
//	return 0;
//}


//
//
//写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那么这个表达式就是存在问题的
//
//

